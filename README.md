# Vuex

### Vuex — паттерн управления состоянием + библиотека для приложений на Vue.js

Представление -> Действие -> Состояния  
                   <-
                   
- Несколько представлений могут зависеть от одной и той же части состояния приложения.
- Действия из разных представлений могут оказывать влияние на одни и те же части состояния приложения.

Решая первую проблему, придётся передавать одни и те же данные входными параметрами в глубоко вложенные компоненты. 
Это часто сложно и утомительно, а для соседних компонентов такое и вовсе не сработает. 

Решая вторую проблему, можно прийти к таким решениям, как обращение по ссылкам к родительским/дочерним экземплярам 
или попыткам изменять и синхронизировать несколько копий состояния через события. Оба подхода хрупки и быстро приводят
к появлению кода, который невозможно поддерживать.

Так почему бы не вынести всё общее состояние приложения из компонентов и управлять им в глобальном синглтоне? 
При этом наше дерево компонентов становится одним большим «представлением», и любой компонент может получить
доступ к состоянию приложения или вызывать действия для изменения состояния, независимо от того, где они находятся в дереве!

В центре любого Vuex-приложения находится хранилище. «Хранилище» — это контейнер, в котором хранится состояние вашего приложения. 
Два момента отличают хранилище Vuex от простого глобального объекта:

Хранилище Vuex реактивно. Когда компоненты Vue полагаются на его состояние,
то они будут реактивно и эффективно обновляться, если состояние хранилища изменяется.

Нельзя напрямую изменять состояние хранилища. Единственный способ внести изменения — явно вызвать мутацию. Это гарантирует, 
что любое изменение состояния оставляет след и позволяет использовать инструментарий, чтобы лучше понимать ход работы приложения.

После установки Vuex, давайте создадим хранилище. Это довольно просто — необходимо указать начальный объект состояния и некоторые мутации:

    import Vue from 'vue'
    import Vuex from 'vuex'

    Vue.use(Vuex)

    const store = new Vuex.Store({
      state: {
        count: 0
      },
      mutations: {
      //state  в мутации передается всегда?
        increment (state) {
          state.count++
        }
      }
    })


Чтобы получить доступ к хранилищу через свойство this.$store в компонентах Vue, необходимо установить созданное хранилище в экземпляр Vue.
Vuex имеет механизм внедрения хранилища во все дочерние компоненты из корневого экземпляра с помощью опции store:

    new Vue({
      el: '#app',
      store: store,
    })


Теперь можно совершить мутацию из метода компонента:

    methods: {
      increment() {
        this.$store.commit('increment')
        console.log(this.$store.state.count)
      }
    }


 <b>commit</b> - запускает мутации mutatuins в strore Vuex - this.$store.commit('increment')
 
 Использование состояния хранилища в компоненте предполагает просто возврат необходимой части состояния в вычисляемом свойстве, поскольку состояние хранилища реактивно.   
 Т.е. Внутри компонентов плучаем данные через вычисляемые свойства, так как состояние хранилища реактивно.
 
 Инициирование изменений — это просто запуск мутаций в методах компонентов.
 
 ###  Состояние
 
Vuex использует единое дерево состояния — когда один объект содержит всё глобальное состояние приложения и служит «единственным источником истины». Это также означает, что в приложении будет только одно такое хранилище. Единое дерево состояния позволяет легко найти нужную его часть или делать снимки текущего состояния приложения в целях отладки.

Итак, как использовать состояние хранилища в компонентах Vue? Поскольку хранилище Vuex реактивно, самый простой способ «получения» — просто вернуть часть состояния хранилища в вычисляемом свойстве (opens new window):

// создадим компонент-счётчик:
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count() {
      return store.state.count; //или this.$store.state.count
    }
  }
};


#### Вспомогательная функция mapState

Когда компонент должен использовать множество свойств или геттеров хранилища, объявлять все эти вычисляемые свойства может быть утомительно. В таких случаях можно использовать функцию mapState, которая автоматически генерирует вычисляемые свойства:

    // В полной сборке функция доступна через Vuex.mapState
    import { mapState } from 'vuex';

    export default {
      // ...
      computed: mapState({
        // стрелочные функции могут сделать код очень кратким
        count: state => state.count,

        // передача строки 'count' аналогична записи `state => state.count`
        countAlias: 'count',

        // для доступа к локальному состоянию через `this`,
        // необходимо использовать обычную функцию
        countPlusLocalState(state) {
          return state.count + this.localCount;
        }
      })
    };

Можно передавать массив строк в mapState, когда имя сопоставляемого вычисляемого свойства совпадает с именем в дереве состояний:

    computed: mapState([
      // проксирует в this.count доступ к store.state.count
      'count'
    ]);
    
 
 mapState в computed просто развернуть таким образом
 
     computed: {
      localComputed () { /* ... */ },
      // смешиваем результат mapState с внешним объектом
      ...mapState({
        // ...
      })
    }
    
 ###  Геттеры    
